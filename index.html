function generateRoomCode() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Guess the Animal</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    .bg-gradient { min-height: 100vh; background: linear-gradient(135deg, #34d399 0%, #3b82f6 50%, #a855f7 100%); display: flex; align-items: center; justify-content: center; padding: 1rem; }
    .card { background: white; border-radius: 1.5rem; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25); padding: 2rem; max-width: 28rem; width: 100%; }
    .card-lg { max-width: 64rem; }
    .text-center { text-align: center; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    h1 { font-size: 2.25rem; font-weight: bold; color: #1f2937; }
    h2 { font-size: 1.875rem; font-weight: bold; color: #1f2937; }
    .text-gray { color: #6b7280; }
    .text-xl { font-size: 1.25rem; }
    input { width: 100%; padding: 0.75rem 1rem; border: 2px solid #d1d5db; border-radius: 0.5rem; font-size: 1.125rem; outline: none; }
    input:focus { border-color: #3b82f6; }
    button { width: 100%; padding: 1rem 1.5rem; font-weight: bold; border-radius: 0.5rem; border: none; cursor: pointer; transition: all 0.2s; font-size: 1rem; }
    button:disabled { background: #d1d5db; cursor: not-allowed; }
    .btn-purple { background: #a855f7; color: white; }
    .btn-purple:hover:not(:disabled) { background: #9333ea; }
    .btn-blue { background: #3b82f6; color: white; }
    .btn-blue:hover { background: #2563eb; }
    .player-card { background: #f3f4f6; border-radius: 0.5rem; padding: 1rem; display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; }
    .avatar { width: 2.5rem; height: 2.5rem; background: #3b82f6; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; }
    .badge { font-size: 0.75rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
    .badge-purple { background: #e9d5ff; color: #7e22ce; }
    .badge-green { background: #bbf7d0; color: #15803d; }
    .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
    .game-header { background: white; border-radius: 1rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); padding: 1.5rem; margin-bottom: 1rem; }
    .score-box { text-align: center; background: #f9fafb; border-radius: 0.5rem; padding: 0.5rem 0.75rem; }
    .score-name { font-size: 0.75rem; color: #6b7280; }
    .score-value { font-size: 1.25rem; font-weight: bold; color: #3b82f6; }
    .sound-box { background: #fef3c7; border: 4px solid #fbbf24; border-radius: 0.75rem; padding: 1.5rem; text-align: center; margin-bottom: 1rem; }
    .timer { font-size: 2.25rem; font-weight: bold; color: #ef4444; }
    .winner-box { background: #dcfce7; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 0.75rem; text-align: center; margin-bottom: 1rem; color: #15803d; font-weight: bold; }
    .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
    .emoji-btn { background: white; border-radius: 0.75rem; padding: 2rem; font-size: 4rem; cursor: pointer; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); transition: transform 0.2s; border: none; }
    .emoji-btn:hover:not(:disabled) { transform: scale(1.05); }
    .emoji-btn:disabled { cursor: not-allowed; }
    .emoji-correct { box-shadow: 0 0 0 4px #22c55e; background: #dcfce7; }
    .emoji-wrong { opacity: 0.5; }
    .result-item { background: #f3f4f6; border-radius: 0.5rem; padding: 1rem; display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
    .result-rank { font-size: 1.5rem; font-weight: bold; color: #6b7280; margin-right: 0.75rem; }
    .result-score { font-size: 1.5rem; font-weight: bold; color: #3b82f6; }
    .trophy { font-size: 4rem; }
    .flex { display: flex; }
    .gap-3 { gap: 0.75rem; }
    .flex-wrap { flex-wrap: wrap; }
    .justify-between { justify-content: space-between; }
    .items-center { align-items: center; }
  </style>
</head>
<body>
  <div id="app"></div>
  
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <script>
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyApv5F-IZHODQdRTC4mhRyn8tucQ7-nbMc",
      authDomain: "guess-the-animal-6bb41.firebaseapp.com",
      databaseURL: "https://guess-the-animal-6bb41-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "guess-the-animal-6bb41",
      storageBucket: "guess-the-animal-6bb41.firebasestorage.app",
      messagingSenderId: "1075279371321",
      appId: "1:1075279371321:web:2281f625f4352f6c7281e8"
    };
    
    let firebaseApp, database;
    try {
      firebaseApp = firebase.initializeApp(FIREBASE_CONFIG);
      database = firebase.database();
    } catch (error) {
      console.error('Firebase init error:', error);
    }

    const ANIMALS = [
      { name: 'Lion', emoji: 'ü¶Å', sound: './lion.wav', options: ['ü¶Å', 'üêØ', 'üêª', 'üê∫', 'ü¶ä', 'üê±'] },
      { name: 'Elephant', emoji: 'üêò', sound: './elephant.wav', options: ['üêò', 'ü¶è', 'ü¶õ', 'ü¶í', 'üê™', 'üêÉ'] },
      { name: 'Dog', emoji: 'üêï', sound: './dog.wav', options: ['üêï', 'üê∫', 'ü¶ä', 'üê±', 'ü¶ù', 'üêπ'] },
      { name: 'Cat', emoji: 'üê±', sound: './cat.wav', options: ['üê±', 'ü¶Å', 'üêØ', 'üêÜ', 'üêï', 'ü¶ä'] },
      { name: 'Cow', emoji: 'üêÑ', sound: './cow.wav', options: ['üêÑ', 'üêÉ', 'üêÇ', 'üêé', 'üêè', 'üêê'] },
      { name: 'Rooster', emoji: 'üêì', sound: './rooster.wav', options: ['üêì', 'ü¶É', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'üê¶'] },
      { name: 'Frog', emoji: 'üê∏', sound: './frog.wav', options: ['üê∏', 'üêä', 'ü¶é', 'üê¢', 'üêç', 'ü¶ñ'] },
      { name: 'Owl', emoji: 'ü¶â', sound: './owl.wav', options: ['ü¶â', 'ü¶Ö', 'ü¶Ü', 'üê¶', 'ü¶ú', 'üêì'] },
      { name: 'Horse', emoji: 'üêé', sound: './horse.wav', options: ['üêé', 'ü¶ì', 'ü¶å', 'üêÑ', 'ü¶ô', 'üê´'] },
      { name: 'Monkey', emoji: 'üêµ', sound: './monkey.wav', options: ['üêµ', 'ü¶ç', 'ü¶ß', 'üêª', 'ü¶ù', 'üê®'] }
    ];

    // Shuffle array function
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    // Get shuffled options for current question
    function getShuffledOptions(questionIndex) {
      return shuffleArray(ANIMALS[questionIndex].options);
    }

    let state = {
      screen: 'menu',
      gameMode: null,
      playerName: '',
      players: [],
      currentQuestion: 0,
      timeLeft: 5,
      scores: {},
      answered: false,
      correctAnswer: null,
      winner: null,
      myPlayerId: '',
      timer: null,
      roomCode: '',
      isHost: false,
      copied: false,
      shuffledOptions: [],
      matchmakingListener: null
    };

    function render() {
      const app = document.getElementById('app');
      
      if (state.screen === 'menu') {
        app.innerHTML = `
          <div class="bg-gradient">
            <div class="card">
              <div class="text-center mb-8">
                <h1 class="mb-2">üéÆ Guess the Animal</h1>
                <p class="text-gray">Multiplayer Sound Game</p>
              </div>
              <div class="mb-6">
                <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20">
              </div>
              <div class="mb-4">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem;">Choose Game Mode:</h3>
                <button id="aiBtn" class="btn-purple mb-4" disabled style="margin-bottom: 0.75rem;">
                  ü§ñ Play with AI
                  <div style="font-size: 0.75rem; opacity: 0.8;">Instant start, AI opponents</div>
                </button>
                <button id="multiBtn" class="btn-blue" disabled>
                  üì° Play Online
                  <div style="font-size: 0.75rem; opacity: 0.8;">Auto-match with real players</div>
                </button>
              </div>
            </div>
          </div>
        `;
        
        const input = document.getElementById('nameInput');
        const aiBtn = document.getElementById('aiBtn');
        const multiBtn = document.getElementById('multiBtn');
        input.addEventListener('input', (e) => {
          state.playerName = e.target.value;
          aiBtn.disabled = !e.target.value.trim();
          multiBtn.disabled = !e.target.value.trim();
        });
        aiBtn.addEventListener('click', () => startSimulatedGame());
        multiBtn.addEventListener('click', () => autoMatchmaking());
      }
      
      else if (state.screen === 'matching') {
        app.innerHTML = `
          <div class="bg-gradient">
            <div class="card">
              <div class="text-center">
                <div style="width: 5rem; height: 5rem; background: #3b82f6; border-radius: 50%; margin: 0 auto 1.5rem; display: flex; align-items: center; justify-content: center; animation: pulse 2s infinite;">
                  <span style="font-size: 2.5rem;">üîç</span>
                </div>
                <h2 class="mb-4">Finding Players...</h2>
                <p class="text-gray">Searching for opponents worldwide</p>
                <div style="margin-top: 1.5rem;">
                  <div style="height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden;">
                    <div style="height: 100%; background: #3b82f6; animation: loading 2s infinite;"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <style>
            @keyframes loading {
              0% { width: 0%; }
              50% { width: 70%; }
              100% { width: 100%; }
            }
          </style>
        `;
      }
      
      else if (state.screen === 'realMode') {
        app.innerHTML = `
          <div class="bg-gradient">
            <div class="card">
              <div class="text-center mb-6">
                <h2 class="mb-2">Real Multiplayer</h2>
                <p class="text-gray">Play with friends online</p>
              </div>
              <button class="btn-blue mb-4" onclick="createRoom()">üë• Create Private Room</button>
              <div style="text-align: center; margin: 1rem 0; color: #6b7280;">or</div>
              <input type="text" id="roomCodeInput" placeholder="Enter room code" maxlength="6" style="text-transform: uppercase; text-align: center; font-family: monospace; margin-bottom: 0.75rem;">
              <button class="btn-blue mb-4" onclick="joinRoom()" style="background: #22c55e;">‚ñ∂Ô∏è Join Private Room</button>
              <button class="btn-blue" onclick="backToMenu()" style="background: #6b7280;">Back</button>
            </div>
          </div>
        `;
      }
      
      else if (state.screen === 'lobby') {
        const playersHtml = state.players.map(p => `
          <div class="player-card">
            <div class="avatar">${p.name[0].toUpperCase()}</div>
            <span style="font-weight: 600; color: #1f2937;">${p.name}</span>
            ${p.isAI ? '<span class="badge badge-purple">AI</span>' : ''}
            ${p.id === state.myPlayerId ? '<span class="badge badge-green">You</span>' : ''}
            ${state.gameMode === 'real' && state.isHost && p.id === state.myPlayerId ? '<span class="badge" style="background: #fef08a; color: #854d0e;">Host</span>' : ''}
          </div>
        `).join('');
        
        app.innerHTML = `
          <div class="bg-gradient">
            <div class="card">
              <h2 class="text-center mb-4">${state.gameMode === 'real' ? 'Waiting Room' : 'Players Ready!'}</h2>
              ${state.gameMode === 'real' && state.roomCode && state.isHost ? `
                <div style="background: #dbeafe; border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; text-align: center;">
                  <p style="font-size: 0.875rem; color: #6b7280; margin-bottom: 0.5rem;">üéÆ You are the host!</p>
                  <p style="font-size: 0.875rem; color: #6b7280;">Waiting for players to join...</p>
                  <p style="font-size: 0.75rem; color: #6b7280; margin-top: 0.5rem;">Players: ${state.players.length}/4</p>
                </div>
              ` : ''}
              ${state.gameMode === 'real' && !state.isHost ? `
                <div style="background: #dcfce7; border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; text-align: center;">
                  <p style="font-size: 0.875rem; color: #15803d;">‚úÖ Connected!</p>
                  <p style="font-size: 0.75rem; color: #15803d; margin-top: 0.25rem;">Waiting for host to start the game...</p>
                </div>
              ` : ''}
              <div class="mb-6">${playersHtml}</div>
              ${state.gameMode === 'real' && state.isHost ? `
                <button class="btn-blue mb-4" onclick="startRealGame()" style="background: #22c55e;">
                  üéÆ Start Game (${state.players.length} ${state.players.length === 1 ? 'player' : 'players'})
                </button>
                <p style="text-align: center; font-size: 0.875rem; color: #6b7280;">Game can start with 1+ players</p>
              ` : ''}
              ${state.gameMode === 'simulated' ? `
                <div class="text-center text-gray">
                  <p class="animate-pulse">Game starting soon...</p>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      }
      
      else if (state.screen === 'game') {
        const animal = ANIMALS[state.currentQuestion];
        const scoresHtml = state.players.map(p => `
          <div class="score-box">
            <div class="score-name">${p.name}</div>
            <div class="score-value">${state.scores[p.id] || 0}</div>
          </div>
        `).join('');
        
        // Use shuffled options or create new shuffle if not exists
        if (!state.shuffledOptions[state.currentQuestion]) {
          state.shuffledOptions[state.currentQuestion] = getShuffledOptions(state.currentQuestion);
        }
        
        const shuffledOpts = state.shuffledOptions[state.currentQuestion];
        const optionsHtml = shuffledOpts.map((emoji, idx) => {
          let btnClass = 'emoji-btn';
          if (state.answered && emoji === state.correctAnswer) btnClass += ' emoji-correct';
          else if (state.answered && emoji !== state.correctAnswer) btnClass += ' emoji-wrong';
          return `<button class="${btnClass}" onclick="handleAnswer('${emoji}')" ${state.answered ? 'disabled' : ''}>${emoji}</button>`;
        }).join('');
        
        app.innerHTML = `
          <div class="bg-gradient">
            <div class="card card-lg">
              <div class="game-header">
                <div class="flex justify-between items-center flex-wrap mb-4">
                  <div style="font-size: 1.25rem; font-weight: bold; color: #1f2937;">Question ${state.currentQuestion + 1}/10</div>
                  <div class="flex gap-3 flex-wrap">${scoresHtml}</div>
                </div>
                <div class="sound-box">
                  <div class="flex items-center justify-center gap-3 mb-4">
                    <span style="font-size: 2rem;">üîä</span>
                    <span style="font-size: 1.5rem; font-weight: bold; color: #1f2937;">Listen to the sound!</span>
                  </div>
                  <button class="btn-blue" onclick="playSound()" style="width: auto; padding: 0.5rem 1.5rem;">üîä Play Again</button>
                </div>
                <div class="text-center mb-4">
                  <div class="timer">‚è±Ô∏è ${state.timeLeft}s</div>
                </div>
                ${state.winner ? `<div class="winner-box">üéâ ${state.winner} answered first!</div>` : ''}
              </div>
              <div class="grid">${optionsHtml}</div>
            </div>
          </div>
        `;
      }
      
      else if (state.screen === 'results') {
        const sorted = [...state.players].sort((a, b) => (state.scores[b.id] || 0) - (state.scores[a.id] || 0));
        const resultsHtml = sorted.map((p, idx) => `
          <div class="result-item">
            <div class="flex items-center">
              <div class="result-rank">#${idx + 1}</div>
              <span style="font-weight: 600; color: #1f2937;">${p.name}</span>
            </div>
            <div class="result-score">${state.scores[p.id] || 0} pts</div>
          </div>
        `).join('');
        
        app.innerHTML = `
          <div class="bg-gradient">
            <div class="card">
              <div class="text-center mb-6">
                <div class="trophy mb-4">üèÜ</div>
                <h2 class="mb-2">Game Over!</h2>
                <p class="text-xl text-gray">Winner: ${sorted[0].name}</p>
              </div>
              <div class="mb-6">${resultsHtml}</div>
              <button class="btn-blue" onclick="resetGame()">Play Again</button>
            </div>
          </div>
        `;
      }
    }

    function startSimulatedGame() {
      if (!state.playerName.trim()) return;
      const playerId = 'player-' + Date.now();
      state.myPlayerId = playerId;
      state.gameMode = 'simulated';
      state.players = [
        { id: playerId, name: state.playerName, isAI: false },
        { id: 'ai-1', name: 'Alex', isAI: true },
        { id: 'ai-2', name: 'Jordan', isAI: true }
      ];
      state.scores = {};
      state.players.forEach(p => { state.scores[p.id] = 0; });
      state.shuffledOptions = [];
      // Pre-shuffle all questions
      for (let i = 0; i < ANIMALS.length; i++) {
        state.shuffledOptions[i] = getShuffledOptions(i);
      }
      state.screen = 'lobby';
      render();
      
      setTimeout(() => {
        state.screen = 'game';
        render();
        playSound();
        startTimer();
      }, 2000);
    }

    function autoMatchmaking() {
      if (!state.playerName.trim() || !database) return;
      
      const playerId = 'player-' + Date.now();
      state.myPlayerId = playerId;
      state.gameMode = 'real';
      
      const openRoomsRef = database.ref('openRooms');
      
      // First, check if there's an available room to join
      openRoomsRef.orderByChild('created').limitToFirst(1).once('value', snapshot => {
        let foundRoom = false;
        
        snapshot.forEach(child => {
          const roomCode = child.key;
          const roomData = child.val();
          
          // Check if room is still open and not full (max 4 players)
          const playerCount = Object.keys(roomData.players || {}).length;
          if (!roomData.started && playerCount < 4) {
            foundRoom = true;
            joinAvailableRoom(roomCode, playerId);
          }
        });
        
        // If no room found, create a new one (become host)
        if (!foundRoom) {
          createOpenRoom(playerId);
        }
      });
    }

    function createOpenRoom(playerId) {
      if (!database) return;
      
      const code = generateRoomCode();
      state.roomCode = code;
      state.myPlayerId = playerId;
      state.isHost = true;
      
      const player = { id: playerId, name: state.playerName, isAI: false };
      
      const roomData = {
        host: playerId,
        players: { [playerId]: player },
        scores: { [playerId]: 0 },
        currentQuestion: 0,
        started: false,
        winner: null,
        answeredCorrectly: false,
        timeoutTriggered: false,
        created: Date.now()
      };
      
      // Add to both openRooms and rooms
      database.ref('openRooms/' + code).set(roomData).then(() => {
        database.ref('rooms/' + code).set(roomData).then(() => {
          state.players = [player];
          state.scores = { [playerId]: 0 };
          state.shuffledOptions = [];
          // Pre-shuffle all questions
          for (let i = 0; i < ANIMALS.length; i++) {
            state.shuffledOptions[i] = getShuffledOptions(i);
          }
          state.screen = 'lobby';
          render();
          listenToRoom(code);
        });
      }).catch(error => {
        console.error('Error creating room:', error);
        alert('Error creating room. Please try again.');
      });
    }

    function joinAvailableRoom(code, playerId) {
      if (!database) return;
      
      const roomRef = database.ref('rooms/' + code);
      const openRoomRef = database.ref('openRooms/' + code);
      
      roomRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          // Room no longer exists, create new one
          createOpenRoom(playerId);
          return;
        }
        
        const roomData = snapshot.val();
        
        if (roomData.started) {
          // Game already started, create new room
          createOpenRoom(playerId);
          return;
        }
        
        const playerCount = Object.keys(roomData.players || {}).length;
        if (playerCount >= 4) {
          // Room is full, create new one
          createOpenRoom(playerId);
          return;
        }
        
        const player = { id: playerId, name: state.playerName, isAI: false };
        
        // Add player to room
        const updates = {
          [`players/${playerId}`]: player,
          [`scores/${playerId}`]: 0
        };
        
        roomRef.update(updates).then(() => {
          // Also update openRooms
          openRoomRef.update(updates).then(() => {
            state.roomCode = code;
            state.myPlayerId = playerId;
            state.isHost = false;
            state.shuffledOptions = [];
            // Pre-shuffle all questions
            for (let i = 0; i < ANIMALS.length; i++) {
              state.shuffledOptions[i] = getShuffledOptions(i);
            }
            state.screen = 'lobby';
            render();
            listenToRoom(code);
            
            // Check if room is now full (4 players)
            roomRef.once('value').then(snap => {
              const data = snap.val();
              if (Object.keys(data.players || {}).length >= 4) {
                // Remove from open rooms if full
                openRoomRef.remove();
              }
            });
          });
        }).catch(error => {
          console.error('Error joining room:', error);
          // If join fails, create new room
          createOpenRoom(playerId);
        });
      });
    }

    function createRoom() {
      if (!state.playerName.trim() || !database) return;
      const code = generateRoomCode();
      const playerId = 'player-' + Date.now();
      state.roomCode = code;
      state.myPlayerId = playerId;
      state.isHost = true;
      state.gameMode = 'real';
      
      const player = { id: playerId, name: state.playerName, isAI: false };
      const roomData = {
        host: playerId,
        players: { [playerId]: player },
        scores: { [playerId]: 0 },
        currentQuestion: 0,
        started: false,
        winner: null,
        answeredCorrectly: false,
        timeoutTriggered: false
      };
      
      database.ref('rooms/' + code).set(roomData).then(() => {
        state.players = [player];
        state.scores = { [playerId]: 0 };
        state.screen = 'lobby';
        render();
        listenToRoom(code);
      }).catch(err => {
        console.error('Error creating room:', err);
        alert('Error creating room');
      });
    }

    function joinRoom() {
      const input = document.getElementById('roomCodeInput');
      const code = input ? input.value.toUpperCase().trim() : '';
      if (!code || !state.playerName.trim() || !database) return;
      
      const playerId = 'player-' + Date.now();
      const roomRef = database.ref('rooms/' + code);
      
      roomRef.once('value').then(snapshot => {
        if (!snapshot.exists()) {
          alert('Room not found!');
          return;
        }
        
        const roomData = snapshot.val();
        if (roomData.started) {
          alert('Game already started!');
          return;
        }
        
        const player = { id: playerId, name: state.playerName, isAI: false };
        roomRef.update({
          ['players/' + playerId]: player,
          ['scores/' + playerId]: 0
        }).then(() => {
          state.roomCode = code;
          state.myPlayerId = playerId;
          state.isHost = false;
          state.gameMode = 'real';
          state.screen = 'lobby';
          render();
          listenToRoom(code);
        });
      }).catch(err => {
        console.error('Error joining:', err);
        alert('Error joining room');
      });
    }

    function listenToRoom(code) {
      if (!database) return;
      const roomRef = database.ref('rooms/' + code);
      
      roomRef.on('value', snapshot => {
        if (!snapshot.exists()) return;
        const data = snapshot.val();
        
        state.players = Object.values(data.players || {});
        state.scores = data.scores || {};
        
        if (data.started && state.screen === 'lobby') {
          state.screen = 'game';
          state.currentQuestion = data.currentQuestion || 0;
          state.timeLeft = 5;
          state.answered = false;
          state.shuffledOptions = [];
          // Pre-shuffle all questions for consistency
          for (let i = 0; i < ANIMALS.length; i++) {
            state.shuffledOptions[i] = getShuffledOptions(i);
          }
          render();
          playSound();
          startLocalTimer();
        }
        
        if (data.currentQuestion !== state.currentQuestion && state.screen === 'game') {
          if (state.timer) clearInterval(state.timer);
          state.currentQuestion = data.currentQuestion;
          state.timeLeft = 5;
          state.answered = false;
          state.correctAnswer = null;
          state.winner = null;
          // Shuffle options for new question
          if (!state.shuffledOptions[state.currentQuestion]) {
            state.shuffledOptions[state.currentQuestion] = getShuffledOptions(state.currentQuestion);
          }
          render();
          playSound();
          startLocalTimer();
        }
        
        if (data.winner && state.screen === 'game' && !state.answered) {
          if (state.timer) clearInterval(state.timer);
          state.winner = data.winner;
          state.answered = true;
          state.correctAnswer = ANIMALS[state.currentQuestion || 0].emoji;
          render();
        }
        
        if (data.ended && state.screen !== 'results') {
          if (state.timer) clearInterval(state.timer);
          state.screen = 'results';
          render();
        }
        
        if (state.screen === 'lobby') render();
      });
    }

    function startLocalTimer() {
      if (state.timer) clearInterval(state.timer);
      
      state.timer = setInterval(() => {
        state.timeLeft--;
        render();
        
        if (state.timeLeft <= 0) {
          clearInterval(state.timer);
          
          if (state.gameMode === 'real' && database) {
            handleMultiplayerTimeout();
          } else {
            handleTimeout();
          }
        }
      }, 1000);
    }

    function handleMultiplayerTimeout() {
      if (!database || state.answered) return;
      
      state.answered = true;
      state.correctAnswer = ANIMALS[state.currentQuestion].emoji;
      render();
      
      const roomRef = database.ref('rooms/' + state.roomCode);
      
      // Use transaction to ensure only one player progresses the game
      roomRef.transaction(function(room) {
        if (!room || room.currentQuestion !== state.currentQuestion) {
          return; // Abort if question already changed
        }
        
        if (!room.timeoutTriggered) {
          room.timeoutTriggered = true;
          return room;
        }
        return; // Abort if timeout already triggered
      }, function(error, committed, snapshot) {
        if (error || !committed) return;
        
        // This player won the race to trigger timeout
        setTimeout(() => {
          roomRef.once('value').then(snap => {
            const currentData = snap.val();
            if (!currentData || currentData.currentQuestion !== state.currentQuestion) return;
            
            if (state.currentQuestion < ANIMALS.length - 1) {
              roomRef.update({ 
                currentQuestion: state.currentQuestion + 1, 
                winner: null,
                winnerId: null,
                answeredCorrectly: false,
                timeoutTriggered: false
              });
            } else {
              roomRef.update({ ended: true });
            }
          });
        }, 1500);
      });
    }

    function startRealGame() {
      if (state.players.length < 2 || !database) return;
      database.ref('rooms/' + state.roomCode).update({ started: true, currentQuestion: 0 });
    }

    function copyCode() {
      navigator.clipboard.writeText(state.roomCode);
      state.copied = true;
      render();
      setTimeout(() => {
        state.copied = false;
        render();
      }, 2000);
    }

    function backToMenu() {
      state.screen = 'menu';
      render();
    }

    function startGame() {
      startSimulatedGame();
    }

    function playSound() {
      const animal = ANIMALS[state.currentQuestion];
      
      // Create audio element
      const audio = new Audio();
      audio.src = animal.sound;
      
      // Add event listeners for debugging
      audio.addEventListener('loadeddata', () => {
        console.log('Audio loaded successfully:', animal.sound);
      });
      
      audio.addEventListener('error', (e) => {
        console.error('Audio error for', animal.sound, ':', e);
        console.log('Falling back to text-to-speech');
        // Fallback to text-to-speech
        const utterance = new SpeechSynthesisUtterance(animal.name);
        utterance.rate = 0.8;
        utterance.pitch = 0.8;
        speechSynthesis.speak(utterance);
      });
      
      // Try to play
      audio.play().catch(error => {
        console.error('Play error:', error);
        // Fallback to text-to-speech
        const utterance = new SpeechSynthesisUtterance(animal.name);
        utterance.rate = 0.8;
        utterance.pitch = 0.8;
        speechSynthesis.speak(utterance);
      });
    }

    function startTimer() {
      if (state.timer) clearInterval(state.timer);
      state.timer = setInterval(() => {
        state.timeLeft--;
        render();
        if (state.timeLeft <= 0) {
          clearInterval(state.timer);
          handleTimeout();
        }
      }, 1000);
    }

    function handleTimeout() {
      const aiAnswered = state.players.find(p => p.isAI && Math.random() > 0.3);
      if (aiAnswered) {
        state.scores[aiAnswered.id]++;
        state.winner = aiAnswered.name;
      }
      state.answered = true;
      state.correctAnswer = ANIMALS[state.currentQuestion].emoji;
      render();
      setTimeout(nextQuestion, 2000);
    }

    function handleAnswer(emoji) {
      if (state.answered) return;
      if (state.timer) clearInterval(state.timer);
      
      const animal = ANIMALS[state.currentQuestion];
      const isCorrect = emoji === animal.emoji;
      
      if (state.gameMode === 'real' && database) {
        const roomRef = database.ref('rooms/' + state.roomCode);
        
        // Use transaction to ensure only first correct answer wins
        roomRef.transaction(function(room) {
          if (!room) return room;
          
          // If there's already a winner for this question, don't update
          if (room.winner) {
            return; // Abort transaction
          }
          
          // If this is a correct answer
          if (isCorrect) {
            room.winner = state.playerName;
            room.winnerId = state.myPlayerId;
            room.scores = room.scores || {};
            room.scores[state.myPlayerId] = (room.scores[state.myPlayerId] || 0) + 1;
            room.answeredCorrectly = true;
          }
          
          return room;
        }, function(error, committed, snapshot) {
          if (error) {
            console.error('Transaction error:', error);
            return;
          }
          
          const data = snapshot.val();
          state.answered = true;
          state.correctAnswer = animal.emoji;
          
          if (committed && isCorrect) {
            state.winner = state.playerName;
            state.scores = data.scores;
          }
          
          render();
          
          // If correct answer, progress immediately after 2 seconds
          if (committed && isCorrect) {
            setTimeout(() => {
              roomRef.once('value').then(snap => {
                const currentData = snap.val();
                if (!currentData || currentData.currentQuestion !== state.currentQuestion) return;
                
                if (state.currentQuestion < ANIMALS.length - 1) {
                  roomRef.update({ 
                    currentQuestion: state.currentQuestion + 1, 
                    winner: null,
                    winnerId: null,
                    timeLeft: 5,
                    answeredCorrectly: false,
                    timeoutProcessed: false
                  });
                } else {
                  roomRef.update({ ended: true });
                }
              });
            }, 2000);
          }
        });
      } else {
        // Simulated mode
        state.answered = true;
        state.correctAnswer = animal.emoji;
        
        if (isCorrect) {
          state.scores[state.myPlayerId]++;
          state.winner = state.playerName;
        } else {
          const aiWinner = state.players.find(p => p.isAI);
          if (aiWinner) {
            state.scores[aiWinner.id]++;
            state.winner = aiWinner.name;
          }
        }
        render();
        setTimeout(nextQuestion, 2000);
      }
    }

    function nextQuestion() {
      if (state.currentQuestion < ANIMALS.length - 1) {
        state.currentQuestion++;
        state.timeLeft = 5;
        state.answered = false;
        state.correctAnswer = null;
        state.winner = null;
        // Shuffle options for the new question
        state.shuffledOptions[state.currentQuestion] = getShuffledOptions(state.currentQuestion);
        render();
        playSound();
        startTimer();
      } else {
        state.screen = 'results';
        render();
      }
    }

    function resetGame() {
      if (state.timer) clearInterval(state.timer);
      if (state.gameMode === 'real' && state.isHost && state.roomCode && database) {
        database.ref('rooms/' + state.roomCode).remove();
        database.ref('openRooms/' + state.roomCode).remove();
      }
      state = {
        screen: 'menu',
        gameMode: null,
        playerName: '',
        players: [],
        currentQuestion: 0,
        timeLeft: 5,
        scores: {},
        answered: false,
        correctAnswer: null,
        winner: null,
        myPlayerId: '',
        timer: null,
        roomCode: '',
        isHost: false,
        copied: false,
        shuffledOptions: [],
        matchmakingListener: null
      };
      render();
    }

    render();
  </script>
</body>
</html>
